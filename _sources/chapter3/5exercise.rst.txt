chapter3练习
=======================================

- 本节难度：编程试水

本章任务
-----------------------------------------------------
- 注意本节任务最终对应一次 lab 提交。
- 老规矩，先 `make test BASE=1` 看下啥情况。
- 理解框架的多任务加载机制，了解此时用户和内核的大概内存布局。在此基础上，实现本章编程作业(1)更安全的 sys_write。
- 理解框架的调度机制，尤其要搞明白时钟中断的处理机制以及 yield 之后下一个进程的选择。在次基础上，完成本节的编程作业(2)stride 调度算法。
- 进一步思考 stride 调度算法，完成本章问答作业。
- 最终，完成实验报告并 push 你的 ch3 分支到远程仓库。ch3报告要求_ 。push 代码后会自动执行 CI，代码给分以 CI 给分为准。

读取目录信息
+++++++++++++++++++++++++++++++

.. note::

    本实验为用户态实验，请在 Linux 环境下完成。

在 Linux 中，我们可以用 `ls` 命令列出某个目录下的文件名，也可以用 `pwd` 命令显示当前工作目录。现在我们来自己实现这两个功能，简单起见，可以不需要考虑额外参数，仅显示程序所在的目录信息和文件名即可。

.. hint:: 或许可以派上用场的系统调用和 C 库函数： `getcwd`, `getwd`, `open`, `opendir`, `readdir`, `getdents`

获取任务信息
++++++++++++++++++++++++++

ch3 中，我们的系统已经能够支持多个任务分时轮流运行，我们希望引入一个新的系统调用 ``sys_task_info`` 以获取任务的信息，定义如下：

.. code-block:: C

    int sys_task_info(unsigned int id, TaskInfo *ts);

- syscall ID: 410
- 根据任务 ID 查询任务信息，任务信息包括任务 ID、任务控制块相关信息（任务状态）、任务使用的系统调用及调用次数、任务总运行时长。

.. code-block:: C

    struct TaskInfo {
        unsigned int id,
        TaskStatus status,
        SyscallInfo[MAX_SYSCALL_NUM] call,
        int time
    };

- 系统调用信息采用数组形式对每个系统调用的次数进行统计，相关结构定义如下：

.. code-block:: C

    struct SyscallInfo {
        unsigned int id,
        unsigned int times
    };

- 参数：
    - id: 待查询任务id
    - ts: 待查询任务信息
- 返回值：执行成功返回0，错误返回-1
- 说明：
    - 相关结构已在框架中给出，只需添加逻辑实现功能需求即可。
- 提示：
    - 大胆修改已有框架！除了配置文件，你几乎可以随意修改已有框架的内容。
    - 程序运行时间可以通过调用 ``get_time()`` 获取。
    - 系统调用次数可以考虑在进入内核态系统调用异常处理函数之后，进入具体系统调用函数之前维护。
    - 阅读 proc 的实现，思考如何维护内核控制块信息（可以在控制块可变部分加入其他需要的信息）

打印调用堆栈（选做）
+++++++++++++++++++++++++++++++

我们在调试程序时，除了正在执行的函数外，往往还需要知道当前的调用堆栈。这样的功能通常由调试器、运行环境、 IDE 或操作系统等提供，但现在我们只能靠自己了。最基本的实现只需打印出调用链上的函数地址，更丰富的功能包括打印出函数名、函数定义、传递的参数等等。

本实验我们不提供测例，仅提供参考实现，各位同学可以通过对照 GDB 、参考实现或自行构造调用链等方式检验自己的实现是否正确。

.. hint:: 可以参考《编译原理》课程中关于函数调用栈帧的内容。

实验要求
+++++++++++++++++++++++++++++++++++++++++

- 完成分支: ch3。

- 实验目录要求

.. code-block::

   ├── os(内核实现)
   │   └── ...
   ├── reports (不是 report)
   │   ├── ch3.md/pdf
   │   └── ...
   ├── ...


- 通过所有测例：

  CI 使用的测例与本地相同，测试中，user 文件夹及其它与构建相关的文件将被替换，请不要试图依靠硬编码通过测试。

.. note::

    你的实现只需且必须通过测例，建议读者感到困惑时先检查测例。

.. ch3问答作业::

问答作业
--------------------------------------------

1. 请学习 gdb 调试工具的使用(这对后续调试很重要)，并通过 gdb 简单跟踪从机器加电到跳转到 0x80200000 的简单过程。只需要描述重要的跳转即可，只需要描述在 qemu 上的情况。

tips: 

  - 事实上进入 rustsbi 之后就不需要使用 gdb 调试了。可以直接阅读代码。 `rustsbi起始代码 <https://github.com/rustsbi/rustsbi-qemu/blob/7d71bfb7b3ad8e36f06f92c2ffe2066bbb0f9254/rustsbi-qemu/src/main.rs#L56>`_ 。
  - 可以使用示例代码 Makefile 中的 ``make debug`` 指令。
  - 一些可能用到的 gdb 指令：
      - ``x/10i 0x80000000`` : 显示 0x80000000 处的10条汇编指令。
      - ``x/10i $pc`` : 显示即将执行的10条汇编指令。
      - ``x/10xw 0x80000000`` : 显示 0x80000000 处的10条数据，格式为16进制32bit。
      - ``info register``: 显示当前所有寄存器信息。
      - ``info r t0``: 显示 t0 寄存器的值。
      - ``break funcname``: 在目标函数第一条指令处设置断点。
      - ``break *0x80200000``: 在 0x80200000 出设置断点。
      - ``continue``: 执行直到碰到断点。
      - ``si``: 单步执行一条汇编指令。


2. 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请同学们可以自行测试这些内容（参考 `前三个测例 <https://github.com/DeathWish5/riscvos-c-tests/tree/main/user/src>`_ ，描述程序出错行为，同时注意注明你使用的 sbi 及其版本。
   
3. 请结合用例理解 `trampoline.S <https://github.com/DeathWish5/uCore-Tutorial-v2/blob/ch2/os/trampoline.S>`_ 中两个函数 `userret` 和 `uservec` 的作用，并回答如下几个问题:

    1. L79: 刚进入 `userret` 时，`a0`、`a1` 分别代表了什么值。 

    2. L87-L88: `sfence` 指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？

        .. code-block:: assembly

            csrw satp, a1
            sfence.vma zero, zero

    3. L96-L125: 为何注释中说要除去 `a0`？哪一个地址代表 `a0`？现在 `a0` 的值存在何处？

        .. code-block:: assembly

            # restore all but a0 from TRAPFRAME
            ld ra, 40(a0)
            ld sp, 48(a0)
            ld t5, 272(a0)
            ld t6, 280(a0)

    4. `userret`：中发生状态切换在哪一条指令？为何执行之后会进入用户态？

    5. L29： 执行之后，a0 和 sscratch 中各是什么值，为什么？

        .. code-block:: assembly

            csrrw a0, sscratch, a0     

    6. L32-L61: 从 trapframe 第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？
        
        .. code-block:: assembly

            sd ra, 40(a0)
            sd sp, 48(a0)
            ...
            sd t5, 272(a0)
            sd t6, 280(a0)

    7. 进入 S 态是哪一条指令发生的？

    8.  L75-L76: `ld t0, 16(a0)` 执行之后，`t0`中的值是什么，解释该值的由来？
        
        .. code-block:: assembly

            ld t0, 16(a0)
            jr t0

4. 请依次简要回答如下问题：

    - 程序陷入内核的原因有中断和异常（系统调用），请问 RISC-V 64 支持哪些中断 / 异常？
    - 如何判断进入内核是由于中断还是异常？请描述陷入内核时的几个重要寄存器及其值。
    - 为了方便 os 处理，Ｍ 态软件会将 S 态异常/中断委托给 S 态软件，请指出有哪些寄存器记录了委托信息。
    - RustSBI 委托了哪些异常/中断？（提示：看看 RustSBI 在启动时输出了什么？）

.. ch3报告要求::

报告要求
-------------------------------
- pdf 格式，CI 网站提交，注明姓名学号。 
- 注意目录要求，报告命名 ``lab1.pdf``，位于 ``reports`` 目录下。命名错误视作没有提交。后续实验同理。
- 简单总结本次实验你新添加的代码。
- 完成问答问题。

- [可选，不占分]你对本次实验设计及难度/工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言。

.. warning::

    请勿抄袭，报告会进行抽样查重！
