

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>引言 &mdash; uCore-Tutorial-Book-v2 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_style.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "rcore-os/rCore-Tutorial-Book-v3");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="特权级机制" href="1rv-privilege.html" />
    <link rel="prev" title="第二章：批处理系统" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> uCore-Tutorial-Book-v2
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Part1 - Just do it!</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter0/index.html">第零章：实验环境搭建</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter1/index.html">第一章：应用程序与基本执行环境</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第二章：批处理系统</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">引言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">本章导读</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">实践体验</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">本章代码导读</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="1rv-privilege.html">特权级机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="2application.html">实现应用程序以及user文件夹</a></li>
<li class="toctree-l2"><a class="reference internal" href="3batch-system.html">实现批处理操作系统的细节</a></li>
<li class="toctree-l2"><a class="reference internal" href="4exercise.html">chapter2练习</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter3/index.html">第三章：多道程序与分时多任务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter4/index.html">第四章：地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter5/index.html">第五章：进程及进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter6/index.html">第六章：进程间通信</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter7/index.html">第七章：文件系统与I/O重定向</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter8/index.html">第八章：拓展实验</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">开发注记</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup-sphinx.html">修改和构建本项目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rest-example.html">reStructuredText 基本语法</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">uCore-Tutorial-Book-v2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第二章：批处理系统</a> &raquo;</li>
        
      <li>引言</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/chapter2/0intro.rst.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>引言<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>本章导读<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>本章展现了操作系统一系列功能：</p>
<ul class="simple">
<li><p>通过批处理支持多个程序的自动加载和运行</p></li>
<li><p>操作系统利用硬件特权级机制，实现对操作系统自身的保护</p></li>
</ul>
<p>上一章，我们在 RV64 裸机平台上成功运行起来了 <code class="docutils literal notranslate"><span class="pre">Hello,</span> <span class="pre">world!</span></code> 并成功实现了染色的过程 。看起来这个过程非常顺利，只需要一条命令就能全部完成。但实际上，在那个计算机刚刚诞生的年代，很多事情并不像我们想象的那么简单。当时，程序被记录在打孔的卡片上，使用汇编语言甚至机器语言来编写。而稀缺且昂贵的计算机由专业的管理员负责操作，就和我们在上一章所做的事情一样，他们手动将卡片输入计算机，等待程序运行结束或者终止程序的运行。最后，他们从计算机的输出端——也就是打印机中取出程序的输出并交给正在休息室等待的程序提交者。</p>
<p>实际上，这样做是一种对于珍贵的计算资源的浪费。因为当时的计算机和今天的个人计算机不同，它的体积极其庞大，能够占满一整个空调房间，像巨大的史前生物。管理员在房间的各个地方跑来跑去、或是等待打印机的输出的这些时间段，计算机都并没有在工作。于是，人们希望计算机能够不间断的工作且专注于计算任务本身。</p>
<p id="term-batch-system"><strong>批处理系统</strong> (Batch System) 应运而生。它的核心思想是：将多个程序打包到一起输入计算机。而当一个程序运行结束后，计算机会 <em>自动</em> 加载下一个程序到内存并开始执行。这便是最早的真正意义上的操作系统。</p>
<p id="term-privilege">程序总是难免出现错误。但人们希望一个程序的错误不要影响到操作系统本身，它只需要终止出错的程序，转而运行执行序列中的下一个程序即可。如果后面的程序都无法运行就太糟糕了。这种 <em>保护</em> 操作系统不受有意或无意出错的程序破坏的机制被称为 <strong>特权级</strong> (Privilege) 机制，它实现了用户态和内核态的隔离，需要软件和硬件的共同努力。</p>
<p>本章我们的主要目的也是设计一个批处理的操作系统。毕竟将待执行的程序嵌入main.c之中是十分粗暴的，也不符合我们对操作系统的认知。这同时也意味着我们将开始使用独立的测例文件，并把它们打包到os之中。</p>
<img alt="../_images/deng-fish.png" class="align-center" id="fish-os" src="../_images/deng-fish.png" />
</div>
<div class="section" id="id3">
<h2>实践体验<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>本章我们引入了用户程序，我们可以通过 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">user</span></code> 生成用户程序，最终将 <code class="docutils literal notranslate"><span class="pre">.bin</span></code> 文件放在 <code class="docutils literal notranslate"><span class="pre">user/target/bin</span></code> 目录下。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git checkout ch2
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make user <span class="nv">BASE</span><span class="o">=</span><span class="m">1</span> <span class="nv">CHAPTER</span><span class="o">=</span><span class="m">2</span>
<span class="gp">$ </span>make run
</pre></div>
</div>
<p>也可以直接运行打包好的测试程序。make test 会完成　make user 和 make run 两个步骤（自动设置 CHAPTER），我们可以通过 BASE 控制是否生成留做练习的测例。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make <span class="nb">test</span> <span class="nv">BASE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>如果你发现自己的 user 目录是空的，这是由于在 clone 的时候没有增加 <code class="docutils literal notranslate"><span class="pre">--recursive</span></code> 参数导致 submodule 没有初始化。解决方案如下：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git submodule init
<span class="gp">$ </span>git submodule update
</pre></div>
</div>
<p>如果顺利的话，我们可以看到批处理系统自动加载并运行所有的程序并且正确在程序出错的情况下保护了自身：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |
|  |\  \----.|  `--&#39;  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|

[rustsbi] Platform: QEMU (Version 0.1.0)
[rustsbi] misa: RV64ACDFIMSU
[rustsbi] mideleg: 0x222
[rustsbi] medeleg: 0xb1ab
[rustsbi-dtb] Hart count: cluster0 with 1 cores
[rustsbi] Kernel entry: 0x80200000
hello wrold!
Hello world from user mode program!
Test hello_world OK!
3^10000=5079
3^20000=8202
3^30000=8824
3^40000=5750
3^50000=3824
3^60000=8516
3^70000=2510
3^80000=9379
3^90000=2621
3^100000=2749
Test power OK!
string from data section
strinstring from stack section
strin
Test write1 OK!
ALL DONE
</pre></div>
</div>
<p>可以看到 4 个基础测试程序都可以正常运行。</p>
</div>
<div class="section" id="id4">
<h2>本章代码导读<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>相比于上一章的操作系统，本章操作系统有两个最大的不同之处，一个是支持应用程序在用户态运行，且能完成应用程序发出的系统调用；另一个是能够一个接一个地自动运行不同的应用程序。所以，我们需要对操作系统和应用程序进行修改，也需要对应用程序的编译生成过程进行修改。</p>
<p>首先改进应用程序，让它能够在用户态执行，并能发出系统调用。这其实就是上一章中  <span class="xref std std-ref">构建用户态执行环境</span> 小节介绍内容的进一步改进。具体而言，编写多个应用小程序，修改编译应用所需的 <code class="docutils literal notranslate"><span class="pre">linker.ld</span></code> 文件来   <span class="xref std std-ref">调整程序的内存布局</span> ，让操作系统能够把应用加载到指定内存地址后顺利启动并运行应用程序。</p>
<p>应用程序运行中，操作系统要支持应用程序的输出功能，并还能支持应用程序退出。这需要完成 <code class="docutils literal notranslate"><span class="pre">sys_write</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_exit</span></code> 系统调用访问请求的实现。 具体实现涉及到内联汇编的编写，以及应用与操作系统内核之间系统调用的参数传递的约定。为了让应用在还没实现操作系统之前就能进行运行测试，我们采用了Linux on RISC-V64 的系统调用参数约定。具体实现可参看 <span class="xref std std-ref">系统调用</span> 小节中的内容。 这样写完应用小例子后，就可以通过  <code class="docutils literal notranslate"><span class="pre">qemu-riscv64</span></code> 模拟器进行测试了。</p>
<p>写完应用程序后，还需实现支持多个应用程序轮流启动运行的操作系统。这里首先能把本来相对松散的应用程序执行代码和操作系统执行代码连接在一起，便于   <code class="docutils literal notranslate"><span class="pre">qemu-system-riscv64</span></code> 模拟器一次性地加载二者到内存中，并让操作系统能够找到应用程序的位置。为把二者连在一起，需要对生成的应用程序进行改造，首先是把应用程序执行文件从ELF执行文件格式变成Binary格式（通过 <code class="docutils literal notranslate"><span class="pre">rust-objcopy</span></code> 可以轻松完成）；然后这些Binary格式的文件通过编译器辅助脚本 <code class="docutils literal notranslate"><span class="pre">scripts/pack.py</span></code> 生成 <code class="docutils literal notranslate"><span class="pre">os/link_app.S</span></code> 这个汇编文件，并生成各个Binary应用的辅助信息，便于操作系统能够找到应用的位置。同时，makefile也会调用另外一个脚本``scripts/kernellld.py``来生一个新的规定程序空间的kernel_app.ld取代之前的kernel.ld。编译器会把把操作系统的源码和 <code class="docutils literal notranslate"><span class="pre">os/link_app.S</span></code> 合在一起，编译出操作系统+Binary应用的ELF执行文件，并进一步转变成Binary格式。</p>
<p>操作系统本身需要完成对Binary应用的位置查找，找到后（通过 <code class="docutils literal notranslate"><span class="pre">os/link_app.S</span></code> 中的变量和标号信息完成），会把Binary应用拷贝到 <code class="docutils literal notranslate"><span class="pre">os/kernel_app.ld</span></code> 指定的物理内存位置（OS的加载应用功能）。</p>
<p>更加详细的内容，主要在 <a class="reference internal" href="3batch-system.html#term-batchos"><span class="std std-ref">实现批处理操作系统</span></a> 小节中讲解。</p>
<p>为了让Binary应用能够启动和运行，操作系统还需给Binary应用分配好执行环境所需一系列的资源。这主要包括设置好用户栈和内核栈（在应用在用户态和内核在内核态需要有各自的栈），实现Trap 上下文的保存与恢复（让应用能够在发出系统调用到内核态后，还能回到用户态继续执行），完成Trap 分发与处理等工作。由于涉及用户态与内核态之间的特权级切换细节的汇编代码，与硬件细节联系紧密，所以 <span class="xref std std-ref">这部分内容</span> 是本章中理解比较困难的地方。如果要了解清楚，需要对涉及到的CSR寄存器的功能有清楚的认识。这就需要看看 <a class="reference external" href="http://crva.ict.ac.cn/documents/RISC-V-Reader-Chinese-v2p1.pdf">RISC-V手册</a> 的第十章或更加详细的RISC-V的特权级规范文档了。有了上面的实现后，就剩下最后一步，实现 <strong>执行应用程序</strong> 的操作系统功能，其主要实现在 <code class="docutils literal notranslate"><span class="pre">run_next_app</span></code> 函数中 。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="1rv-privilege.html" class="btn btn-neutral float-right" title="特权级机制" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="第二章：批处理系统" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020, Yifan Wu.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>